<!--
  
  Built by Eric Mill:

    konklone@gmail.com
    twitter.com/konklone
    github.com/konklone

  Hosted on Nodejitsu (nodejitsu.com), an excellent Node.js app host.

  Flags mostly "borrowed" from flagpedia.net (thanks Flagpedia!) and Wikipedia.

  Thanks to @micahbrich and @btj for all of their help.
  
  Made of two Node apps:
    Main site - github.com/isitchristmas/web
    Streaming - github.com/isitchristmas/sockets

  Tech stack:
    Node.js, WebSockets, SockJS, Redis, MongoDB

  Services used:
    Nodejitsu, OpenRedis, MongoLab, MaxMind, Logentries

  Bug reports and stuff:
    github.com/isitchristmas/web/issues

  = Open up the dev console =

-->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Is it Christmas?</title>
  <link rel="alternate" title="Is It Christmas?" href="rss.xml" type="application/rss+xml" />

  <style type="text/css">
    html, body {height: 100%;}
    body {text-align: center;}

    a#answer {
      display: inline-block;
      margin-top: 200px;
      font-weight: bold;
      font-size: 120pt; 
      font-family: Arial, sans-serif; 
      text-decoration: none; 
      color: black;
    }

    .flag {
      position: absolute;
      cursor: none;
    }

    .flag.me {pointer-events: none;}

    .flag img {
      border: 1px solid #d6d6d6;
      -webkit-border-radius: 2px;
         -moz-border-radius: 2px;
           -o-border-radius: 2px;
              border-radius: 2px;

      -webkit-transition: opacity 1s;
         -moz-transition: opacity 1s;
           -o-transition: opacity 1s;
              transition: opacity 1s;
    }

    /* click effect, width and height set dynamically */
    .click {
      position: absolute;
      border: 1px solid #000;

      -webkit-border-radius: 3px;
         -moz-border-radius: 3px;
              border-radius: 3px;

      -webkit-transition: 0.5s ease-out;
         -moz-transition: 0.5s ease-out;
           -o-transition: 0.5s ease-out;
              transition: 0.5s ease-out;
    }

    #legend {      
      position: fixed;
      top: 0; right: 0;
      width: 200px;
      padding-right: 15px; padding-top: 5px;
      text-align: right;
      font-size: 10pt;

      -webkit-transition: 0.25s linear;
         -moz-transition: 0.25s linear;
           -o-transition: 0.25s linear;
              transition: 0.25s linear;
    }
  </style>

  <script type="text/javascript" src="christmas.js"></script>

  <!--[if IE 9 ]>
    <script type="text/javascript">window._ie9 = true;</script>
  <![endif]-->
</head>

<body>
  <!-- 
    Initial 'title' and noscript values are server-side fallbacks,
    calculated with UTC, for clients who do not have JS enabled.
  -->
  <a id="answer"
    href="#" onclick="return false"
    title="<%= answer %>">
    <noscript><%= answer %></noscript>
  </a>

  <div id="legend"></div>
  
  <!-- replace fallback data with locally calculated values -->
  <script type="text/javascript">
    var country = "<%= country %>";
    if (!(Christmas.countries[country] && Christmas.countries[country].width))
      country = "EO";

    var me = {
      country: country
    };

    var checkedAt; // store last check, to manage race conditions
    function updateChristmas(isIt) {
      me.christmas = isIt;

      var answer;
      if (isIt == 2)
        answer = Christmas.oct();
      else if (isIt)
        answer = Christmas.yes(country);
      else
        answer = Christmas.no(country);

      var elem = document.getElementById('answer');
      elem.innerHTML = answer;
      elem.setAttribute("title", answer);

      checkedAt = Date.now();
    }

    updateChristmas(Christmas.isIt());
  </script>


  <% if (env == "production") { %>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-252618-5']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  <% } %>

  
  <!-- optional: interaction -->
  <script src="/browser.js"></script>
  <script src="/css.js"></script>
  <script src="/sockjs.min.js"></script>
  <script type="text/javascript">
    
    var socket;
    var others = {};

    var user = {
      log: {
        join: false, // join/leave messages

        info: false,   // default
        debug: false, // you know

        life: true,  // life and death events
        public: true // messages for the public
      },

      retry: {
        id: null, // the timeout id
        initial: 500, // milliseconds
        multiplier: 2, // multiply after every retry
        current: 500 // will change
      },

      // values can be overwritten on hello
      live: {
        mouse_rate: 20,
        heartbeat_interval: 3000,
        death_interval: 6000,
        chat: "true"
      }
    };

    // kept separate because I like emitting the entire 'me' hash at times
    var meFlag = null;

    // sockjs server endpoint
    <% if (req.param("streaming")) { %>
      var url = "<%= req.param("streaming") %>/christmas";
    <% } else { %>
      <% var random = Math.floor(Math.random() * config.streaming.length); %>
      var url = "<%= config.streaming[random] %>/christmas";
    <% } %>

    // whether activity is visible to the user
    var visible = <%= (req.param("visible") || config.visible) ? "true" : "false" %>;

    // whether to force into readonly mode (see mice, but no sending of own action)
    var force_readonly = <%= req.param("readonly") || "false" %>;

    // force it to use a particular transport
    var transport = "<%= req.param("transport") || "" %>";

    // allowed transports
    var default_transports = [
      "websocket", // most everyone nowadays
      "xhr-streaming", // older versions of non-IE, and when networks block websockets
      "xdr-streaming" // IE9
    ];

    // tiny events/commands system
    var events = {};
    var commands = {};
    function on(event, func) {events[event] = func;}
    function command(cmd, func) {commands[cmd] = func;}
    function noop() {};

    // managing heartbeats
    var heartbeat, death; 
    var suicide = false; // why would you do this

    // welcome user once, then after every 10 chat messages received.
    // turn off when the user first uses say().
    var said = false;
    var chatsSince = 0;

    var legend = document.getElementById("legend")
      , legendTimeout;

    var christmasTimer
      , christmasEndTimer;

    function connect(host) {
      socket = new SockJS(host, null, {
        protocols_whitelist: transport ? [transport] : default_transports
      });

      socket.onopen = function() {
        log.info("= Connected via " + socket.protocol);
        
        me.transport = socket.protocol;

        // XDR doesn't have good enough upstream speed for mouse motion
        me.readonly = force_readonly || (me.transport == "xdr-streaming");

        // reset retry timer, we're in
        user.retry.current = user.retry.initial;
      };

      socket.onmessage = function(message) {
        var data = JSON.parse(message.data);
        (events[data._event] || noop)(data);
      };

      socket.onclose = function() {
        onDeath();
      };
    }


    var rawSend = function(message) {socket.send(message)};
    var limiters = {
      chat: ratelimit(rawSend, 500),
      click: ratelimit(rawSend, 20),
      motion: ratelimitMouse(rawSend) // dynamic
    };

    function emit(event, data) {
      if (!me.id || !me.transport) {
        log.info("= Weird state! Trying to emit events with no ID. :|")
        return;
      }

      data = data || {};
      data._event = event;
      var message = JSON.stringify(data);
      (limiters[event] || rawSend)(message);
    }
      

    // event listeners 

    on('hello', function(data) {
      me.id = data._user_id;
      me.server = data.server;
      if (!me.name)
        me.name = data.name;
      log.info("= Assigned ID: " + me.id + " [on: " + me.server + "]");
      
      // server-overridden client options
      for (var key in data.live)
        user.live[key] = data.live[key];

      if (user.live.chat == "true")
        welcomeUser();
      
      me.browser = BrowserDetect.browser;
      me.version = BrowserDetect.version;
      me.os = BrowserDetect.OS;
      me.time = Date.now();

      // all users announce their info to the server and start a heartbeat
      emit('arrive', me);
      setHeartbeat();
      setCursor();

      // update me to indicate I've sent 'arrive' once
      // server will know that future connects are reconnects
      me.alreadyArrived = true;

      document.onmousemove = function(event) {
        event = event || window.event;
        
        // only show it on first movement
        if (meFlag._new && visible && event.clientX && event.clientY) {
          document.body.appendChild(meFlag);
          document.body.style.cursor = "none";
          document.getElementById("answer").style.cursor = "none";
          meFlag._new = false;
        }

        moveFlag(meFlag, 
          event.clientX + window.pageXOffset, 
          event.clientY + window.pageYOffset
        );
        
        if (!me.readonly) {
          emit('motion', {
            x: event.clientX + window.pageXOffset,
            y: event.clientY + window.pageYOffset,
            id: me.id,
            c: me.country
          });
        }
      };

      document.onmousedown = function(event) {
        event = event || window.event;

        // :(
        if (me.readonly || window._ie9) return; 

        var x = event.clientX + window.pageXOffset;
        var y = event.clientY + window.pageYOffset;

        doClick(me.country, x, y);

        if (!me.readonly) {
          emit('click', {
            id: me.id, 
            x: x, 
            y: y,
            country: me.country
          });
        }
      };
    });

    var welcomeUser = function() {
      log.public("= say(\"message\") to speak, rename(\"Name\") to change names.");
    };

    var onDeath = function() {
      log.life("= Disconnected! :(");

      clearTimeout(heartbeat);
      clearTimeout(death);

      for (var id in others)
        removeOther(id);

      document.onmousemove = null;
      document.onmousedown = null;

      me.id = null;
      me.transport = null;
      me.time = null;
      if (meFlag && meFlag.parentElement)
        meFlag.parentElement.removeChild(meFlag);

      setRetry();
    };

    var setRetry = function() {
      log.life("= Retrying in " + user.retry.current + "ms...");
      user.retry.id = setTimeout(function() {
        connect(url);
      }, user.retry.current);

      user.retry.current = user.retry.current * user.retry.multiplier;
    }

    var setHeartbeat = function() {
      clearTimeout(heartbeat);
      heartbeat = setTimeout(function() {
        log.debug("heartbeat: beating");
        emit("heartbeat", me);
      }, parseInt(user.live.heartbeat_interval));

      death = setTimeout(function() {
        log.life("= Died from lack of heartbeat :(")
        socket.close();
      }, parseInt(user.live.death_interval));
    };

    on("heartbeat", function(data) {
      if (suicide) return; // let death take me

      clearTimeout(death); // death averted
      log.debug("heartbeat: returned, death averted");

      setHeartbeat();
    });

    on('arrive', function(other) {
      registerOther(other);

      // let a new arrival know you are already here
      emit("here", {
        to: other.id,
        id: me.id,
        country: me.country
      });
    });

    on('here', function(other) {
      registerOther(other);
    });

    on('motion', function(other) {
      // toss junk motion
      if (!(other.x && other.y)) return;

      if (!others[other.id] || !others[other.id].flag)
        showOther(other);

      moveFlag(others[other.id].flag, other.x, other.y);
    });

    on('click', function(other) {
      // :(
      if (me.readonly || window._ie9) return;

      doClick(other.country, other.x, other.y);
    });

    on('leave', function(data) {
      removeOther(data.id);
    });

    on('config', function(data) {
      log.info("= live config change: " + data.key + " [" + user.live[data.key] + " -> " + data.value + "]");
      user.live[data.key] = data.value;
    });

    on('command', function(data) {
      log.info("= command: " + data.command + " (" + data.arguments.join(",") + ")");
      (commands[data.command] || noop).apply(null, data.arguments);
    })

    on('chat', function(data) {
      if (!said) {
        chatsSince += 1;
        if (chatsSince >= 10) {
          welcomeUser();
          chatsSince = 0;
        }
      }
      log.public("[" + data.country + "] " + data.name + ": " + data.message);
    });

    command('blast', function(message) {
      log.public("= Server message: " + message);
    })

    command('reconnect', function() {
      log.public("= Server asked us to reconnect, closing connection");
      socket.close();
    });

    command('refresh', function() {
      log.public("= Server asked us to refresh, whooaaaaa");
      window.location = window.location;
    })

    var say = function(message) {
      if (!message) return;
      if (user.live.chat != "true") return;

      said = true;
      emit('chat', {
        id: me.id,
        name: me.name,
        country: me.country,
        message: message,
        time: Date.now()
      });
    };

    var rename = function(name) {
      if (!name) return;

      // 20 char max;
      me.name = name.slice(0,20);

      log.public("= Your name: " + me.name);
    };

    var setCursor = function() {
      meFlag = flagFor(me.country, "me");
      meFlag._new = true;
      meFlag.style.zIndex = 9999; // on top of the world
    };

    var registerOther = function(other) {
      if (others[other.id])
        return;

      others[other.id] = {country: other.country};

      log.join("[" + other.id + "] Joined from " + other.country + " (" + Christmas.countries[other.country].name + ")");
    };

    // the creation of an element per-user is only sparked by that user's mouse motion.
    // so read-only (non-WS) clients will connect and be known, but not cause
    // elements to be generated.
    var showOther = function(other) {
      // make up for shortened key name
      other.country = other.country || other.c; 

      // in case this comes before the 'arrive' event does
      registerOther(other); 

      others[other.id].flag = flagFor(other.country, "other");
      if (visible)
        document.body.appendChild(others[other.id].flag);
    };

    var moveFlag = function(flag, x, y) {
      if (x && y) {
        flag.style.left = "" + x + "px";
        flag.style.top = "" + y + "px";
      }
    };

    var doClick = function(country, x, y) {
      if (!visible) return;

      var elem = document.createElement("div");

      var width = Christmas.countries[country].width || 40;
      var height = 20;
      var xOff = Math.floor(width / 2);
      var yOff = Math.floor(height / 2);

      elem.className = "click";
      elem.style.width = "" + width + "px";
      elem.style.height = "" + height + "px";
      elem.style.left = "" + (x - xOff) + "px";
      elem.style.top = "" + (y - yOff) + "px";

      document.body.appendChild(elem);
      setTimeout(function() {
        elem.style.width = "" + (width*2) + "px";
        elem.style.height = "" + (height*2) + "px";
        elem.style.borderColor = "#fff";
        elem.style.left = "" + (x - width) + "px";
        elem.style.top = "" + (y - height) + "px";
        setTimeout(function() {
          elem.parentElement.removeChild(elem);
        }, 500);
      }, 10);
    };

    var removeOther = function(id) {
      if (!others[id]) return;
      var country = others[id].country;
      
      var elem = others[id].flag;
      if (elem && elem.parentElement)
        elem.parentElement.removeChild(elem);

      delete others[id];
      log.join("[" + id + "] Departed from " + country + " (" + Christmas.countries[country].name + ")");
    };

    // prevent click-drags from "grabbing" image
    document.body.onmousedown = function(event) {
      event = event || window.event;
      if (event.preventDefault) event.preventDefault();
      else event.returnValue = false;
    };

    var flagFor = function(country, klass) {
      var div = document.createElement('div');
      div.className = "flag " + klass;

      var flag = document.createElement('img');
      flag.src = "countries/" + country + ".png";

      div.onmouseover = function() {
        clearTimeout(legendTimeout);
        legend.innerHTML = Christmas.countries[country].names.join("<br/>");
        legend.style.opacity = 1;
        legendTimeout = setTimeout(function() {
          legend.style.opacity = 0;
        }, 30000)
      };

      
      div.appendChild(flag);
      
      // without this, div adds height padding, weird
      div.style.height = "20px";

      div.style.marginTop = "-" + yOff(country) + "px";
      div.style.marginLeft = "-" + xOff(country) + "px";

      return div;
    };

    var xOff = function(country) {
      var width = Christmas.countries[country].width || 40;
      return width / 2;
    }

    var yOff = function(country) {
      return 10; // all flags are 20px high;
    }

    function ratelimit(fn, interval) {
      var last = (new Date()).getTime();
      return (function() {
        var now = (new Date()).getTime();
        if ((now - last) > interval) {
          last = now;
          return fn.apply(null, arguments);
        }
      });
    }

    // special version of ratelimit that looks to live-changeable value
    function ratelimitMouse(fn) {
      var last = (new Date()).getTime();
      return (function() {
        var now = (new Date()).getTime();
        if ((now - last) > user.live.mouse_rate) {
          last = now;
          fn.apply(null, arguments);
        }
      });
    }

    // live flip when it's Xmas, and when it's not again
    var flagRule = addCSSRule("img");
    var clickRule = addCSSRule("div.click");
    var legendRule = addCSSRule("div#legend");
    function flagFade(centerTime) {
      // fade out, then in
      setTimeout(function() {
        flagRule.style.opacity = 0;
        legendRule.style.display = "none";
        clickRule.style.display = "none";
        
        setTimeout(function() {
          flagRule.style.opacity = 1;
          legendRule.style.display = "block";
          clickRule.style.display = "block";
        }, 5000); // 2 seconds after center

      }, (centerTime - Date.now()) - 3000); // 3 seconds before center (fade is 1s)
    }

    function setTimers() {
      var nextXmas = Christmas.thisYear();
      // var nextXmas = new Date(Date.now() + (5 * 1000)); // 5 seconds from now
      // var nextXmas = new Date(Date.now()); // pretend we showed up a few milliseconds before
      
      nextXmas = nextXmas.getTime();

      var afterXmas = nextXmas + (24 * 60 * 60 * 1000); // 1 day later
      // var afterXmas = nextXmas + (10 * 1000); // 10 seconds later

      // console.log("Christmas set for: " + new Date(nextXmas));
      // console.log("Christmas ends: " + new Date(afterXmas));

      if (checkedAt < nextXmas) {

        flagFade(nextXmas);

        christmasTimer = setTimeout(function() {
          log.public("Christmas!");
          updateChristmas(true);
        }, (nextXmas - Date.now()));
      }

      if (checkedAt < afterXmas) {

        flagFade(afterXmas);

        christmasEndTimer = setTimeout(function() {
          log.public("Not Christmas.");
          updateChristmas(false);
        }, (afterXmas - Date.now()));
      }
    }


    // minimalist logging system

    var log = function(message, severity) {
      if (user.log[severity]) console.log(message);
    };
    log.debug = function(message) {log(message, "debug")};
    log.info = function(message) {log(message, "info")};
    log.join = function(message) {log(message, "join")};
    log.public = function(message) {log(message, "public")};
    log.life = function(message) {log(message, "life")};

    
    // browser-specific fixes

    // IE fix: make console.log be okay
    if (!window.console) window.console = {};
    if (!window.console.log) window.console.log = function() {};

    // Firefox fix: prevent ESC from closing websockets connection
    if (window.addEventListener)
      window.addEventListener('keydown', function(e) { (e.keyCode == 27 && e.preventDefault()) })

    // IE9 fix: XDR does not allow http->https communication, fall back to http
    if (window._ie9) url = url.replace("https", "http");

    setTimers();
    connect(url);

  </script>
</body>
</html>